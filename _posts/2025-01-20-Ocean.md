---
title: Dive into the deep secrets of rendering a realistic ocean.
background: /img/oceanIMG.png
layout: post
subtitle: Ocean Rendering
artist: Jim van der Heijden
---
# Water in modern games

<hr>
How do modern games render water, I always asked myself? In this blog post I am going to explain the deep secrets of how big studios render water in detail. There are a lot of aspects and ways to make use of water so to make it a little simpler to follow I am going to focus on oceans in specific. 

So let's start at the beginning by looking at a couple implementations of games that make great use of an ocean.

<video width="420" height="360" controls>
  <source src="/img/horizonzerodawn.mp4" type="video/mp4">
</video>
[*Horizon forbidden west swimming through a rough ocean*](https://www.youtube.com/watch?v=XT-xhCNalPc)


<video width="420" height="360" controls>
  <source src="/img/seaofthieves.mp4" type="video/mp4">
</video>
[*Sea of thieves ocean with light scattering through the waves*](https://www.youtube.com/watch?v=aGogFt4bhTM)

# The big question is how can we achieve this?

<hr>
### What do we need
There are 2 major components that we need to create a realistic looking ocean the first component is an oceanographic spectra and the second component is the fast Fourier transform which I will explain later on in this post.
### Setting up the energy spectrum
So what is this Oceanographic spectra? It is formula that simulates ocean waves under certain conditions, these waves are produced by different wind speeds over big areas and gravity lowers the wave amplitudes. Luckily for us we don't have to get the data from these ocean ourselves since other people did the work for us. I decided to use the [JONSWAP](https://www.codecogs.com/library/engineering/fluid_mechanics/waves/spectra/jonswap.php) (Joint North Sea Wave Project) spectrum for my implementation since it has a lot of artistical control and is based of accurate data of the north sea.

<img src="/img/Fig16-9s.jpg" alt="Image" width="400"/>
<br>*JONSWAP spectra wave amplitude at certain frequency*

Now that we have our energy spectrum function we want to randomly sample it and put all the data into a texture this is done with the formula:

$\hat{h}_0​(k) = \frac{1}{\sqrt{2}} (\xi_r + \xi_i) \sqrt{P(k)}$
<br>*P(k) | Wave energy spectrum of choice*
<br>*(ξr​+ξi​) | Gaussian distributed real and imaginary random numbers*
<br>We run this formula for every pixel of the texture so performance scales depending how detailed you want the waves to look, I am using a 512x512 texture since this is perfect for real-time games. The output of this will look something relatively close to this texture depending on what energy spectrum you used.

<img src="/img/initialSpectrum.png" alt="Image" width="400"/>
<br>The origin of the spectrum is in the center, the distance from the origin is the frequency, the pixels value is the amplitude and the direction from the origin to the pixel is the direction of the wave. 

### Cooley-Tukey FFT algorithm
<hr>

Now that we have the frequencies we want to convert this to something visual we can do this with the Inverse Fast Fourier Transform, which converts our frequency domain texture to the time domain.

The IFFT is an algorithm that efficiently computes the DFT(discrete Fourier transform) which makes it faster for real-time, since the DFT is used to transform signals from the time domain into the frequency domain we want to calculate it's inverse.

The most common algorithm to calculate the FFT is the [Cooley-Tukey algorithm](https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm) and we use the radix-2 DIT case which is the simplest form of the algorithm. The algorithm divides a DFT of size _N_ into two interleaved DFTs (hence the name "radix-2") of size _N_/2 with each recursive stage. In our case _N_ is the size of our texture.

For this algorithm we need to sort the data so that the even and odd numbers are grouped together we do this by doing a binary reversal on the index of the pixel so px1, px2, ..., after reversing the binaries we simply count up the numbers and we are left with the first half being even numbers and the second half being odd.

 <img src="/img/shapes at 25-01-22 12.57.07.png" alt="Image" width="400"/>
<br> Now that we have the data ordered correctly we have one last step left, and that is calculating the DFTs. The algorithm gains its speed by re-using the results of intermediate computations to compute multiple DFT outputs. Note that final outputs are obtained by a +/− combination of $E_k$ and $O_k$ $exp(-2 πik/N)$
<br> $E_k$ | means even number, and k is the index
<br> $O_k$ | means on even number, and k is the index
<br> $N$ | is the size of the texture

 <img src="/img/butterflyAlgorithm.png" alt="Image" width="400"/>
 <br> *DFT butterfly computations*

It is not necessary to know how it exactly works but If you are looking for an even more in depth explanation I would recommend watching this [video](https://www.youtube.com/watch?v=h7apO7q16V0)
## Creating a displacement and slope map

